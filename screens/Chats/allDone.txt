// Packages Imports
import {
  useContext,
  useEffect,
  useLayoutEffect,
  useReducer,
  useRef,
} from "react";
import { View, FlatList, Keyboard } from "react-native";
import { io } from "socket.io-client";

// Component Imports
import configurations from "../../config/config";
import ChatsAPI from "../../api/ChatsAPI";
import ChatHeader from "../../components/ChatHeader";
import ChatKeyboard from "../../components/ChatKeyboard";
import FileModal from "../../components/FileModal";
import Helper from "../../utils/Helper";
import GlobalContext from "../../contexts/GlobalContext";
import MessageCard from "../../components/MessageCard";
import { MessageProps } from "../../types/ComponentTypes";
import ToastMessages from "../../constants/Messages";
import useLoading from "./../../hooks/useLoading";
import useDocumentPicker from "./../../hooks/useDocumentPicker";

// useReducers imports
import chatRoomReducer, {
  chatRoomInitialState,
} from "../../store/chatRoom/reducer";
import ChatRoomActionCreators from "../../store/chatRoom/actions";

// function component for ChatRoomScreen
function ChatRoomScreen({ navigation, route }) {
  // Local States and Contexts
  const { Loading, SetLoading } = useLoading({ initialValue: false });
  const { User } = useContext(GlobalContext);

  // Local Refs
  const socket = useRef(io(configurations.baseUrl));
  const FLatListRef = useRef<FlatList>(null);
  const Skip = useRef(0);

  // reducer and dispatcher for the chat room_id
  const [state, dispatch] = useReducer(chatRoomReducer, chatRoomInitialState);

  // Custom Hooks
  const { PickDocument, selectedFile, unselectFile, setSelectedFile } =
    useDocumentPicker();

  // Route Parameters
  const room_id = route?.params?._id;
  const owner_id = User?._id;
  const reciever_id = route.params?.chatting_with?._id;
  const receiver_name = route.params?.chatting_with?.name;
  const reciever_profile_picture = route.params?.chatting_with?.profile_picture;
  const reciever_phone = route.params?.chatting_with?.phone;

  // Initial useEffect call
  useEffect(() => {
    InitialCall();
  }, []);

  // Socket Initialization
  useEffect(() => {
    socket.current.emit("joinRoom", { username: owner_id, room: room_id });

    socket.current.on("message", (message) => {
      if (message.sender_id !== owner_id) AddToChatThread(message);
    });

    socket.current.on("type-update-emitter", (message) => {
      if (message.typer !== owner_id) {
        if (message.message === "start")
          dispatch(ChatRoomActionCreators.SetTyping(true));
        else dispatch(ChatRoomActionCreators.SetTyping(false));
      }
    });

    socket.current.on("roomUsers", ({ users }) => {
      OtherUserEntered(users.length);
    });

    return () => {
      socket.current.disconnect();
    };
  }, []);

  // Changes in chat_thread
  useEffect(() => {
    Skip.current = state.chat_thread.length;

    if (state.chat_thread.length > 0) {
      // Update the last message in redux store
    }
  }, [state.chat_thread]);

  // Update the other user that I am typing through socket
  useEffect(() => {
    if (state.message.length) {
      if (socket.current) {
        socket.current.emit("type-update", {
          message: `start`,
          typer: owner_id,
        });
      }
    }

    const timeout = setTimeout(() => {
      if (socket.current) {
        socket.current.emit("type-update", {
          message: `stop`,
          typer: owner_id,
        });
      }
    }, 1500);

    return () => clearTimeout(timeout);
  }, [state.message]);

  // useLayoutEffect to update the user details in the header
  useLayoutEffect(() => {
    navigation.setOptions({
      header: ({ navigation }) => (
        <ChatHeader
          subtitle={
            state.online_users > 1
              ? state.is_user_typing
                ? "Typing..."
                : "Online"
              : null
          }
          online={state.online_users > 1}
          imageUri={reciever_profile_picture}
          name={receiver_name}
          phone={reciever_phone}
          onBackPress={() => navigation.goBack()}
        />
      ),
    });
  }, [navigation, state.online_users, state.is_user_typing, owner_id]);

  // initial call
  const InitialCall = async () => {
    try {
      SetLoading(true);
      await GetMessages();
      await MarkAsReadAPI();
      SetLoading(false);
    } catch (error) {
      SetLoading(false);
    }
  };

  // API call to get the chat thread
  const GetMessages = async () => {
    try {
      const apiResponse = await ChatsAPI.GetMessages(
        {
          room_id: room_id,
          skip: Skip.current,
        },
        User?.auth_token
      );

      if (apiResponse.ok) {
        if (apiResponse.data.messages.length) {
          let payload = [...state.chat_thread, ...apiResponse.data.messages];
          dispatch(ChatRoomActionCreators.SetChatThread(payload));
        }
      }
    } catch (error) {}
  };

  const OtherUserEntered = (count) => {
    try {
      dispatch(ChatRoomActionCreators.SetUsersCount(count));
      dispatch(ChatRoomActionCreators.MarkMessageAsRead(owner_id));
    } catch (error) {}
  };

  // API to call when current user joins the room_id
  const MarkAsReadAPI = async () => {
    try {
      await ChatsAPI.MarkAsRead(room_id, User?.auth_token);
      // MarkChatAsRead(room_id, owner_id);
    } catch (error) {}
  };

  // Fucntoin to send a message to the socket to other user
  const SendToSocket = async (data) => {
    try {
      if (socket.current) {
        socket.current.emit("chatMessage", data);
      }
    } catch (error) {}
  };

  // Render Item Function
  const renderItem = ({ item, index }: { item?: MessageProps; index: any }) => (
    <MessageCard
      {...item}
      upper_date={null}
      onMessagePress={() =>
        item.message_type === "file" ? setSelectedFile(item.message_file) : null
      }
    />
  );

  // Add an item to the CHatThread array
  const AddToChatThread = (data) => {
    dispatch(ChatRoomActionCreators.SetMessage(""));
    dispatch(ChatRoomActionCreators.UpdateChatThread(data));
  };

  // Send Message
  const SendMessage = async () => {
    // generate a unique id for the message
    const temp_id = Helper.GenerateUniqueID();

    try {
      // Dimsiss the keyboard and bring the Flatlist to the bottom
      Keyboard.dismiss();
      FLatListRef.current.scrollToOffset({ animated: false, offset: 0 });

      // get the current message and trim it.
      let message = state.message.trim();

      // if message is empty, return
      if (message.length === 0) return;

      // prepare the socket payload
      let socket_payload = {
        room_id: room_id,
        message: message,
        message_type: "text",
        sender_id: owner_id,
        reciever_id: reciever_id,
        delivered: false,
        read: state.online_users > 1 ? true : false,
        _id: temp_id,
        message_datetime: Date.now(),
      };

      // prepare the api payload
      const api_payload: any = new FormData();
      api_payload.append("room_id", room_id);
      api_payload.append("message", message);
      api_payload.append("read", state.online_users > 1 ? true : false);

      // add the message to chat Thread
      AddToChatThread(socket_payload);

      // Call API
      const response = await ChatsAPI.SendMessage(api_payload, User.auth_token);

      // if response is ok, send the message to the socket
      // otherwise delete the message from chat thread
      if (response.ok) {
        SendToSocket(response.data.newMessage);
        dispatch(
          ChatRoomActionCreators.UpdateMessageItem(
            temp_id,
            response.data.newMessage
          )
        );
      } else {
        dispatch(ChatRoomActionCreators.RemoveMessageItem(temp_id));
        Helper.ShowToast(response.data.message);
      }
    } catch (error) {
      // Show Toast in case of error
      Helper.ShowToast(ToastMessages.SERVER_ERROR_MESSAGE);
      dispatch(ChatRoomActionCreators.RemoveMessageItem(temp_id));
    }
  };

  // Send File
  const SendFileMessage = async () => {
    try {
      Keyboard.dismiss();

      const api_payload: any = new FormData();
      api_payload.append("room_id", room_id);
      api_payload.append("message", state.message);
      let file_payload: any = {
        uri: selectedFile.uri,
        type: selectedFile.mimeType,
        name: selectedFile.name,
      };
      api_payload.append("file", file_payload);
      api_payload.append("read", state.online_users > 1 ? true : false);

      dispatch(ChatRoomActionCreators.SetSendLoading(true));
      const response = await ChatsAPI.SendMessage(api_payload, User.auth_token);
      dispatch(ChatRoomActionCreators.SetSendLoading(false));

      if (response.ok) {
        SendToSocket(response.data.newMessage);
        AddToChatThread(response.data.newMessage);
        unselectFile();
      } else {
        Helper.ShowToast(response.data.message);
      }
    } catch (error) {
      Helper.ShowToast(ToastMessages.SERVER_ERROR_MESSAGE);
      dispatch(ChatRoomActionCreators.SetSendLoading(false));
    }
  };

  // render
  return (
    <View style={{ flex: 1 }}>
      <FlatList
        data={state.chat_thread}
        ref={FLatListRef}
        onEndReachedThreshold={0.5}
        onEndReached={GetMessages}
        inverted
        keyboardShouldPersistTaps="always"
        showsVerticalScrollIndicator={false}
        keyExtractor={(item) => item._id.toString()}
        renderItem={renderItem}
      />

      <ChatKeyboard
        value={state.message}
        loading={state.send_loading}
        onChangeText={(text) =>
          dispatch(ChatRoomActionCreators.SetMessage(text))
        }
        onSubmit={() => SendMessage()}
        onPickPress={PickDocument}
      />

      <FileModal
        placeholder="Type a Message.."
        isVisible={selectedFile !== null}
        mimeType={selectedFile?.mimeType}
        onBackButtonPress={unselectFile}
        onChangeText={(text) =>
          dispatch(ChatRoomActionCreators.SetMessage(text))
        }
        onSubmit={() => SendFileMessage()}
        loading={state.send_loading}
        onDismiss={unselectFile}
        value={state.message}
        uri={selectedFile?.uri}
        showKeyboard={true}
      />
    </View>
  );
}

// Exports
export default ChatRoomScreen;
